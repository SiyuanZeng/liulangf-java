package com.liulangf.java8.nashorn;

import org.junit.Test;

/**
 *  In Nashorn the so called “JavaScript” classes are been generated. There is a special tool “nasgen” 
 *  for that and it is locates in the “buildtools/nasgen” directory.
 *  
 *  Have in mind that some of classes – so called “JavaScript” classes are been generated. 
 *  Their “bootstrapping” classes are annotated with @ScriptObject. 
 *  
 *  Take some time to explore them. They cannot be debugged from that perspective. 
 *  But “System.out.println” might help
 */
public class NasgenToolTest {

	/**
	 * http://bugs.java.com/view_bug.do?bug_id=8033951
	 * 
	 * JDK-8033951 : nasgen needs the newly build nasgen and nashorn classes in the bootclasspath

During the nashorn build, the nasgen tool is called as follows:

<boot_jdk>/bin/java \
  -Xms64M -Xmx1100M \
  -XX:PermSize=32m \
  -XX:MaxPermSize=160m \
  -XX:ThreadStackSize=1536 \
  -cp "<build_dir>/nashorn/nasgen_classes:<build_dir>/nashorn/nashorn_classes"\
  jdk.nashorn.internal.tools.nasgen.Main \
  <build_dir>/nashorn/classes jdk.nashorn.internal.objects <build_dir>/nashorn/classes

The problem is that the call puts the newly created nashorn and nasgen class (which also include the required asm class) into the class path. This will lead to problems, if the boot jdk contains different version of some of these classes.

Until now, this problem was seldom, because the jdk7 doens't contain any of these classes, so no conflicts could occur. But building a new version of jdk8/jdk9 with an older jdk8 build may lead to build errors like this:

/share/software/Java/jdk1.8.0_ea_b70/bin/java -Xms64M -Xmx1100M -XX:ThreadStackSize=1536 \
            -Xbootclasspath/p:"/tmp/jdk9-client-opt/nashorn/nasgen_classes" -cp "/tmp/jdk9-client-opt/nashorn/nashorn_classes" \
            jdk.nashorn.internal.tools.nasgen.Main /tmp/jdk9-client-opt/nashorn/classes jdk.nashorn.internal.objects /tmp/jdk9-client-opt/nashorn/classes
Exception in thread "main" java.lang.NoClassDefFoundError: jdk/nashorn/internal/objects/annotations/ScriptClass
        at jdk.nashorn.internal.tools.nasgen.ScriptClassInfo.<clinit>(ScriptClassInfo.java:52)
        at jdk.nashorn.internal.tools.nasgen.ScriptClassInfoCollector.visitAnnotation(ScriptClassInfoCollector.java:82)
        at jdk.internal.org.objectweb.asm.ClassReader.accept(ClassReader.java:670)
        at jdk.internal.org.objectweb.asm.ClassReader.accept(ClassReader.java:535)
        at jdk.nashorn.internal.tools.nasgen.ClassGenerator.getScriptClassInfo(ClassGenerator.java:370)
        at jdk.nashorn.internal.tools.nasgen.ClassGenerator.getScriptClassInfo(ClassGenerator.java:365)
        at jdk.nashorn.internal.tools.nasgen.Main.process(Main.java:104)
        at jdk.nashorn.internal.tools.nasgen.Main.processAll(Main.java:88)
        at jdk.nashorn.internal.tools.nasgen.Main.main(Main.java:62)
make[1]: *** [/tmp/jdk9-client-opt/nashorn/classes/_the.nasgen.run] Error 1
make[1]: Leaving directory `/net/usr.work/d046063/OpenJDK/jdk9-client/nashorn/make'

Also see the message "Compilation failure due to mismatching internal classes in the boot JDK" at http://mail.openjdk.java.net/pipermail/nashorn-dev/2014-January/002687.html

The fix for this is easy - just put the required classes in the boot class path instead just in the class path.
	 * 
	 */
	@Test
	public void buildBootstrap() {
	}

	/**
	 
Nasgen is a tool for processing Java classes that implement native
JavaScript objects. It does so by looking for the
com.oracle.nashorn.objects.annotations.ScriptClass annotation and other
annotations in that package.

For each  class "C", nasgen instruments the original class and generates
two additional classes: a "C$Prototype" class for the JavaScript
prototype object, and a "C$Constructor" class for the JavaScript
constructor function.

Each class instrumented or generated by nasgen contains a private static
"$nasgenmap$" field of type com.oracle.nashorn.runtime.PropertyMap and
static initializer block to initialize the field to the object's
JavaScript properties.

Members annotated with @Function, @Property, @Getter, and @Setter are
mapped to the $Constructor, $Prototype, or main class, depending on the
value of the annotation's 'where' field. By default, @Property, @Getter,
and @Setter belong to the main class while @Function methods without
explicit 'where' field belong to the $Prototype class. The @Constructor
annotation marks a method to be invoked as JavaScript constructor.

Nasgen enforces all @Function/@Getter/@Setter/@Constructor annotated
methods to be declared as static. Static final @Property fields remain
in the main class while other @Property fields are moved to respective
classes depending on the annotation's 'where' value. For functions
mapped to the $Prototype or $Constructor class, nasgen also generates
getters and setters prefixed by G$ and S$, respectively.

Nasgen-generated classes are hidden from normal ClassLoaders by giving
them a ".clazz" file name extension instead of the standard ".class"
extension. This allows script classes to be loaded independently by each
Nashorn context through the com.oracle.nashorn.runtime.StructureLoader
class loader.
	 * 
	 */
	@Test
	public void nasgenToolTest() {
	}

}
